# -*- coding: utf-8 -*-
"""
Created on Thu Aug 29 19:47:34 2019

@author: Jeremy
"""

import numpy as np
import tkinter as tk
from tkinter import filedialog
import time
import pandas as pd
import xlsxwriter as xls

import os
import matplotlib.pyplot as plt
import imageio
import math

# Lance l'explorateur pour sélectionner les fichiers et le ferme
Files_ALL=str()
while len(Files_ALL)==0:
    root = tk.Tk()
    Files_ALL = filedialog.askopenfilenames(title="Select a file", filetypes = (("CSV File", "*.csv*"),("all files","*.*")))
    root.destroy()

# On change le file directory
Dir1 = Files_ALL[0].split('/') ; Dir = str()
for i in np.arange(0, len(Dir1)-1):
    Dir += Dir1[i]+'/'
os.chdir(Dir)

# On renseigne le framerate de la caméra pour convertir le temps
Framerate = 0
while Framerate == 0:
    Framerate = input("What's the framerate of the videos ?\n")
    try :
        if int(Framerate) in range(9999):
            break
    except ValueError:
        print("The input has to be a numerical value.")
        Framerate=0
Framerate = int(Framerate)

# Récupère l'heure à laquelle le programme se lance pour donner le temps de traitement
Start = time.time()

# On demande le nom du fichier excel souhaité
Nom_Fichier = input('Name for the final excel file : ')
if Nom_Fichier == '':
    Nom_Fichier = 'Delete'

# On crée un fichier excel, on crée un feuillet, et on set la largeur des colonnes à 15
End_File = xls.Workbook(f'{Nom_Fichier}.xlsx')
End_format = End_File.add_format({'bold': True}) 
Mean_sheet = End_File.add_worksheet('Means')
Mean_sheet.set_column(0,10,15) ; Mean_Var = ['File','Ang_Min', 'Ang_Max', 'Ang_Mean', 'Ang_Med', 'Acc_Min', 'Acc_Max']
Events_sheet = End_File.add_worksheet('Events')
Events_sheet.set_column(0,10,15) ; Mean_Var_Events = ['File', 'Nb_Events (/Min)', 'Ang_Flex', 'Ang_Ext', 'Acc_Flex', 'Acc_Ext']
End_sheet = End_File.add_worksheet('ALL_Angles')
End_sheet.set_column(0,len(Files_ALL)*2,15)

# Sur la case B3, on écrit Time(s), en gras (End_Format)
End_sheet.write('B3', 'Time (s)', End_format)

# Dans l'onglet des moyennes, on écrit les variables en ligne à partir de B2
Mean_sheet.write_row('B2', Mean_Var, End_format)
Events_sheet.write_row('B2', Mean_Var_Events, End_format)

# Time_Len permet d'écrire la colonne de temps de la video la plus longue dans l'excel
# Body permet de redemander de choisir les joints si des videos ne présentent pas les mêmes ou dans le même ordre 
Time_Len = 0 ; Body = []

""" La boucle fichier par fichier """
for file in np.arange(0,len(Files_ALL)):
    
    NameFile = Files_ALL[file].split('/')
    Mean_sheet.write(file+2,1,NameFile[-1])
    Events_sheet.write(file+2,1,NameFile[-1])
    
    # On charge le fichier .csv dans un premier temps
    # Tourne en boucle tant que le(s) fichier(s) sélectionné(s) ne sont pas approprié(s)
    try:
        Data_Animal = pd.read_csv(Files_ALL[file], skiprows=1)
    except:
        print('Selected files were not generated by DLC.\n Restart and select appropriate files.')
        break
    if Data_Animal.columns[0] != 'bodyparts':
        print('Selected files were not generated by DLC.\n Restart and select appropriate files.')
        break
    
    # On récupère le nom des points traqués
    Bodyparts = [Data_Animal.columns[x] for x in np.arange(1, len(Data_Animal.columns), 3)]
            
    if Body != Bodyparts :        
        # On demande ensuite les 3 articulations formant l'angle à analyser
        Quest_Bodyparts = str()
        for parts in np.arange(0, len(Bodyparts)):
            Quest_Bodyparts += f'{parts+1}-{Bodyparts[parts]}\n'
        Resp_Bodyparts = 0
        while Resp_Bodyparts == 0 :
            Resp_Bodyparts = input('Select 3 joints (the ankle has to be in second position) :\n'+Quest_Bodyparts+'\n')
            try :
                if int(Resp_Bodyparts) in range(999):
                    break
            except ValueError:
                print("The input has to be a sequence of 3 numbers (123).")
            if len(Resp_Bodyparts) != 3 :
                print("The input has to be a sequence of 3 numbers (123).")
                Resp_Bodyparts = 0
        Body = Bodyparts
    
    Knee = int(Resp_Bodyparts[2])-1; Ankle = int(Resp_Bodyparts[1])-1; Foot = int(Resp_Bodyparts[0])-1
        
    # On recharge le fichier csv pour garder que les données intéressantes
    Data_Animal = pd.read_csv(Files_ALL[file], skiprows=2, index_col='coords')
    Col_Names = [x for x in Data_Animal.columns]

    # On récupère les X et Y de chaque bodypart
    X_Bodyparts = [Data_Animal[Col_Names[x]].to_numpy() for x in np.arange(0, len(Col_Names),3)]    
    Y_Bodyparts = [Data_Animal[Col_Names[x]].to_numpy() for x in np.arange(1, len(Col_Names),3)]
    
    X_Norm = [] ; Y_Norm = []
    for body in np.arange(0,len(X_Bodyparts)):            
        X_Norm.append(X_Bodyparts[body]-X_Bodyparts[Knee])
        Y_Norm.append(Y_Bodyparts[body]-Y_Bodyparts[Knee])
    
    # On crée la liste du temps en secondes et on l'écrit dans l'excel
    Time = [x/Framerate for x in np.arange(0,len(X_Bodyparts[0]))]
    if len(Time) > Time_Len:
        Time_Len = len(Time)
        End_sheet.write_column('B4',Time)

    # On calcule les coordonnées des vecteurs ayant pour origine la cheville
    # Les coordonnées du vecteur AK sont xAK = xK - xA ; yAK = yK - yA
    Ankle_Knee_X = X_Bodyparts[Knee]-X_Bodyparts[Ankle]
    Ankle_Knee_Y = Y_Bodyparts[Knee]-Y_Bodyparts[Ankle]
    
    # Les coordonnées du vecteur AF sont xAF = xF - xA ; yAF = yF - yA
    Ankle_Foot_X = X_Bodyparts[Foot]-X_Bodyparts[Ankle]
    Ankle_Foot_Y = Y_Bodyparts[Foot]-Y_Bodyparts[Ankle]

    # On calcule enfin l'angle de la cheville
        # La norme d'un vecteur ||AK|| = V(xAK² + yAK²)
    Norm_AK = np.sqrt(Ankle_Knee_X**2 + Ankle_Knee_Y**2) ; Norm_AF = np.sqrt(Ankle_Foot_X**2 + Ankle_Foot_Y**2)
        # Le produit scalaire d'un angle KAF = AK.AF = xAK*xAF + yAK*yAF
    Scal_Prod = Ankle_Knee_X*Ankle_Foot_X + Ankle_Knee_Y*Ankle_Foot_Y
        # On récupère le sinus de l'angle pour extraire le signe
    Sign = Ankle_Knee_X*Ankle_Foot_Y - Ankle_Knee_Y*Ankle_Foot_X
        # Le cos(KAF) = Produit scalaire de KAF / ||AK||*||AF||
    C = np.nan_to_num(Scal_Prod/(Norm_AK*Norm_AF))
        # On multiplie l'arccos de l'angle par le signe du sinus 
        # Cela donne l'angle en radian 
        # Si le résultat est positif :
            # On multiplie par 180/pi pour le transformer en °
            # Sinon on ajoute à 180° la différence entre 180 et l'angle "négatif"
            # Exemple : Angle de -178° correspond à un angle de 182° 
    Angles = [np.arccos(C[x])*180/math.pi for x in np.arange(0,len(C))]
    # Angles_Rad = [np.sign(Sign[x])*np.arccos(C[x]) for x in np.arange(0,len(C))]
    # Angles = []
    # for x in np.arange(0,len(Angles_Rad)):
    #     if Angles_Rad[x] > 0:
    #         if Ankle_Knee_X[0]>0:
    #             Angles.append(Angles_Rad[x]*180/math.pi)
    #         else:
    #             Angles.append(360-(Angles_Rad[x]*180/math.pi))
    #             if Angles[-1] > 180:
    #                 Angles[-1] = np.float64(180)
    #     else:
    #         if Ankle_Knee_X[0]>0:
    #             Angles.append(180 + (180+(Angles_Rad[x]*180/math.pi)))
    #         else:
    #             Angles.append(360-(180 + (180+(Angles_Rad[x]*180/math.pi))))
    #             if Angles[-1] > 180:
    #                 Angles[-1] = np.float64(180)
    
    # On calcule la moyenne des angles chaque seconde de vidéo
    Angles_Mean_Sec = [np.mean(Angles[x:x+Framerate]) for x in np.arange(0,len(Angles),Framerate)]
    
    # On récupère l'angle mini et maxi ainsi que les indices correspondants
    Angle_Min = min(Angles); Angle_Max = max(Angles); 
    if len(Angles)%2 == 0:
        Angle_Med = np.median(Angles[0:-1])
    else :
        Angle_Med = np.median(Angles)
    IndMin = np.where(Angles==Angle_Min)[0][0]
    IndMax = np.where(Angles==Angle_Max)[0][0]
    IndMed = np.where(Angles==Angle_Med)[0][0]
    
    Mean_sheet.write(file+2,2,Angle_Min); Mean_sheet.write(file+2,3,Angle_Max)
    Mean_sheet.write(file+2,4,np.mean(Angles)); Mean_sheet.write(file+2,5,Angle_Med)
    
    # Enfin on récupère les changements d'angles à chaque frame
    Acc = [0]
    for x in np.arange(1, len(Angles)):
        Acc.append(Angles[x]-Angles[x-1])
        
    Mean_sheet.write(file+2,6,min(Acc)); Mean_sheet.write(file+2,7,max(Acc))
    
    """ On trouve ensuite le nombre de mouvement sur la vidéo & on donne chaque paramètres sur les mouvements"""
    Seuil = 10; Acc_Seuil = [0]; Acc_Events= [] ; Angles_Seuil = [Angles[0]]
    for evt in np.arange(1,len(Acc)) :
        if Acc[evt] > Seuil or Acc[evt] < - Seuil :
            Acc_Seuil.append(Acc[evt])
            Angles_Seuil.append(Angles[evt])
            if evt == 1 or len(Acc_Events) == 0:
                if Acc[evt-1] < Seuil :
                    Acc_Events.append(evt-1)
            elif evt > 5:
                if (Acc[evt-5:evt] < np.full((1,5),Seuil)).all() and (Acc[evt-5:evt] > np.full((1,5),-Seuil)).all() :
                    Acc_Events.append(evt-1)
        else :
            Acc_Seuil.append(np.nan)
            Angles_Seuil.append(np.nan)
    
    Nb_Events_Min = len(Acc_Events)/Time[-1]*60
    Events_sheet.write(file+2,2,Nb_Events_Min)
    
    Flexions = []; Extensions = []; Flexions_A = []; Extensions_A = []
    for zeros in np.arange(0,len(Acc_Seuil)):
        if Acc_Seuil[zeros] == 0 or np.isnan(Acc_Seuil[zeros]):
            Extensions.append(np.nan) ; Flexions.append(np.nan)
            Flexions_A.append(np.nan) ; Extensions_A.append(np.nan)
        if Acc_Seuil[zeros] < 0 :
            Flexions.append(Acc_Seuil[zeros]) ; Extensions.append(np.nan)
            Flexions_A.append(Angles_Seuil[zeros]) ; Extensions_A.append(np.nan)
        if Acc_Seuil[zeros] > 0 :
            Extensions.append(Acc_Seuil[zeros]) ; Flexions.append(np.nan)
            Extensions_A.append(Angles_Seuil[zeros]) ; Flexions_A.append(np.nan)
    
    Flexions_Acc = [np.nanmin(Flexions[Acc_Events[evt-1]:Acc_Events[evt]]) for evt in np.arange(1,len(Acc_Events))]
    Extensions_Acc = [np.nanmax(Extensions[Acc_Events[evt-1]:Acc_Events[evt]]) for evt in np.arange(1,len(Acc_Events))]
    
    Flexions_Angles = [np.nanmin(Flexions_A[Acc_Events[evt-1]:Acc_Events[evt]]) for evt in np.arange(1,len(Acc_Events))]
    Extensions_Angles = [np.nanmax(Extensions_A[Acc_Events[evt-1]:Acc_Events[evt]]) for evt in np.arange(1,len(Acc_Events))]
       
    Acc_Seuil = np.nan_to_num(Acc_Seuil); Angles_Seuil = np.nan_to_num(Angles_Seuil)
    Flexions_Angles = np.nan_to_num(Flexions_Angles); Flexions_Acc = np.nan_to_num(Flexions_Acc)
    Extensions_Angles = np.nan_to_num(Extensions_Angles); Extensions_Acc = np.nan_to_num(Extensions_Acc)
    
    if len(Flexions_Acc)>0:
        Events_sheet.write(file+2,3,np.mean(Flexions_Angles)); Events_sheet.write(file+2,5,np.mean(Flexions_Acc))
    else :
        Events_sheet.write(file+2,3,'None'); Events_sheet.write(file+2,5,'None')
    if len(Extensions_Acc)>0:
        Events_sheet.write(file+2,4,np.mean(Extensions_Angles)); Events_sheet.write(file+2,6,np.mean(Extensions_Acc))
    else:
        Events_sheet.write(file+2,4,'None'); Events_sheet.write(file+2,6,'None')
    
    # On écrit les valeurs d'angles et de changement d'angles dans l'excel ouvert avant la boucle
    if len(Angles)>0:
        End_sheet.write(1, 2*file+2, f'Animal_{file+1}', End_format)
        End_sheet.write(2, 2*file+2, 'Angle', End_format) ; End_sheet.write(2, 2*file+3, 'Acceleration', End_format)
        End_sheet.write_column(3, 2*file+2, Angles) ; End_sheet.write_column(3, 2*file+3, Acc) ; 
   
    """ On plot le tout, on fait apparaître l'angle mini, max et médian """
    if Nom_Fichier != 'Delete' :
        plt.plot(Acc_Seuil)
        plt.scatter(Acc_Events, [Acc_Seuil[x] for x in Acc_Events],c=['#F42525'])
        plt.savefig(f'Ankle_accelerations_{file+1}.svg', format='svg', bbox_inches='tight')
        plt.close()
        
        for i in np.arange(0,len(X_Norm[0])):
             xs1 = [0, X_Norm[Ankle][i]] ; ys1 = [0, -Y_Norm[Ankle][i]]
             xs2 = [X_Norm[Ankle][i],X_Norm[Foot][i]] ; ys2 = [-Y_Norm[Ankle][i],-Y_Norm[Foot][i]]
             plt.plot(xs1,ys1,xs2,ys2, color='#F7D18D', alpha=0.15,zorder=1)
        xs1min = [0, X_Norm[Ankle][IndMin]] ; ys1min = [0, -Y_Norm[Ankle][IndMin]]
        xs2min = [X_Norm[Ankle][IndMin],X_Norm[Foot][IndMin]] ; ys2min = [-Y_Norm[Ankle][IndMin],-Y_Norm[Foot][IndMin]]
        xs1max = [0, X_Norm[Ankle][IndMax]] ; ys1max = [0, -Y_Norm[Ankle][IndMax]]
        xs2max = [X_Norm[Ankle][IndMax],X_Norm[Foot][IndMax]] ; ys2max = [-Y_Norm[Ankle][IndMax],-Y_Norm[Foot][IndMax]]
        xs1med = [0, X_Norm[Ankle][IndMed]] ; ys1med = [0, -Y_Norm[Ankle][IndMed]]
        xs2med = [X_Norm[Ankle][IndMed],X_Norm[Foot][IndMed]] ; ys2med = [-Y_Norm[Ankle][IndMed],-Y_Norm[Foot][IndMed]]
        plt.plot(xs1min, ys1min, xs2min, ys2min, color='#FFA91F', linewidth=3,zorder=1)
        plt.plot(xs1max, ys1max, xs2max, ys2max, color='#FFA91F', linewidth=3,zorder=1)
        plt.plot(xs1med, ys1med, xs2med, ys2med, color='#F42525', linewidth=3,zorder=1)
        plt.scatter([0,xs1med[1],xs2med[1]],[0,ys1med[1],ys2med[1]], 50, c=['#3A62A3'],zorder=2)
        
        if Ankle_Knee_X[0]>0:
            plt.annotate(Bodyparts[Knee], (10, 0), va = 'center'); plt.annotate(Bodyparts[Ankle], (xs1med[1]-10, ys1med[1]), ha='right', va = 'center');
            plt.annotate(Bodyparts[Foot], (xs2med[1]+10, ys2med[1]), va = 'center')
        else:
            plt.annotate(Bodyparts[Knee], (-10, 0),ha='right', va = 'center'); plt.annotate(Bodyparts[Ankle], (xs1med[1]+10, ys1med[1]), va = 'center');
            plt.annotate(Bodyparts[Foot], (xs2med[1]-10, ys2med[1]), ha='right', va = 'center')
        plt.axis('square')
        
        plt.savefig(f'Ankle_movements_{file+1}.svg', format='svg', bbox_inches='tight')
        plt.close()
        
    """ On peut aussi faire un .gif, c'est cool"""
    # filenames = []
    # for i in np.arange(0,5*Framerate):
    #     xs1 = [0, X_Norm[Ankle][i]] ; ys1 = [0, -Y_Norm[Ankle][i]]
    #     xs2 = [X_Norm[Ankle][i],X_Norm[Foot][i]] ; ys2 = [-Y_Norm[Ankle][i],-Y_Norm[Foot][i]]
    #     plt.plot(xs1,ys1,xs2,ys2, color='#FFA91F', linewidth=4, zorder=1)
    #     plt.scatter([0,xs1[1],xs2[1]],[0,ys1[1],ys2[1]],100,c=['#3A62A3'],zorder=2)
    #     plt.xlim([-50, 300]) ; plt.ylim([-250, 100])
    #     filename = f'{i}.png'
    #     filenames.append(filename)
    #     plt.savefig(filename)
    #     plt.close()
    # with imageio.get_writer(f'Ankle_Movements_{file+1}.gif', mode='I') as writer:
    #     for filename in filenames :
    #         image = imageio.imread(filename)
    #         writer.append_data(image)     
    # for filename in set(filenames):
    #     os.remove(filename)
    
End_File.close()
if Nom_Fichier == 'Delete':
    os.remove(f'{Nom_Fichier}.xlsx')
print(round(time.time()- Start,0)//60, 'minutes', round(time.time()- Start,0)%60, 'secondes')
